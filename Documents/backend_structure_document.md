# Backend Structure Document

This document explains how the backend of the Brand2Stand POP Display Design Automation App is set up. It uses plain language so anyone can understand how data flows, where it’s stored, and how different pieces talk to each other.

## 1. Backend Architecture

• **Supabase as the core backend service**  
  - Handles user sign-up, login, and session management out of the box.  
  - Provides a managed PostgreSQL database for storing projects, prompts, and image URLs.  
  - Offers real-time updates, so the UI can reflect database changes instantly.

• **Serverless functions for AI integrations**  
  - Deployed on a platform like Vercel or Netlify.  
  - Written in TypeScript and organized as small “service” modules:  
    • falService: wraps calls to Fal.ai’s Imagen 4 API.  
    • openaiService: wraps calls to OpenAI’s GPT-4o-mini.  
    • projectService: handles CRUD operations against Supabase.

• **Design patterns and organization**  
  - **Service Layer**: each external integration lives in its own module.  
  - **API Layer**: exposes clean RESTful endpoints for the front end to call.  
  - **Separation of Concerns**: business logic (prompt building, error handling) stays separate from HTTP routing.

How this scales, stays maintainable, and stays fast:  
- **Scalability**: Supabase and serverless providers automatically scale out to meet demand—no manual server management.  
- **Maintainability**: TypeScript + ESLint keep code consistent and type-safe. Modular files mean small, focused code units.  
- **Performance**: Serverless endpoints are geographically distributed, and Supabase uses connection pooling. Combined with CDN for static assets, response times stay low.

---

## 2. Database Management

• **PostgreSQL (via Supabase)**  
  - A traditional relational database that stores tables, enforces relationships, and supports advanced features like JSONB columns.  
  - Backed by automated daily backups and maintenance from Supabase.

• **Data Structure & Access**  
  - We store user accounts in Supabase’s built-in `auth.users` table.  
  - Projects, prompts, and image URLs live in custom tables.  
  - Row-Level Security (RLS) ensures each user can only see and modify their own data.  
  - All database queries go through the projectService module to keep queries consistent and centralized.

• **Data Management Practices**  
  - Use environment variables for database credentials—no secrets in source code.  
  - Validate and sanitize inputs at both the API layer and database constraints.  
  - Periodic housekeeping tasks (archiving old projects if needed) can be scheduled via Supabase functions or external cron jobs.

---

## 3. Database Schema

**Human-Readable Overview**  
1. **users** (managed by Supabase)  
   - id, email, created_at, etc.  
2. **projects**  
   - Unique ID, reference to user, form inputs (brand, product, stand specs), generated prompt, enhanced prompt, timestamps.  
3. **project_images**  
   - Unique ID, reference to project, image URL, timestamp.

**SQL Definition (PostgreSQL)**  
```sql
-- Table: projects
CREATE TABLE projects (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) NOT NULL,
  project_name TEXT,
  brand_name TEXT,
  target_audience TEXT,
  product_type TEXT,
  stand_type TEXT,
  materials TEXT,
  dimensions JSONB,
  design_notes TEXT,
  generated_prompt TEXT,
  enhanced_prompt TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Table: project_images
CREATE TABLE project_images (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
  image_url TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

---

## 4. API Design and Endpoints

We follow a simple RESTful style. All endpoints require a valid Supabase JWT.

• **Projects**  
  - `GET /api/projects`  → List all projects for the logged-in user.  
  - `POST /api/projects`  → Create a new project with form inputs.  
  - `GET /api/projects/:id`  → Retrieve details (inputs, prompts, images) for one project.  
  - `PUT /api/projects/:id`  → Update project inputs or prompts.  
  - `DELETE /api/projects/:id`  → Remove a project and its images.

• **Prompt Enhancement**  
  - `POST /api/prompts/enhance`  
    • Body: `{ prompt: string }`  
    • Returns: refined prompt generated by GPT-4o-mini.

• **Image Generation**  
  - `POST /api/images/generate`  
    • Body: `{ prompt: string }`  
    • Returns: array of image URLs from Fal.ai.

• **Image Editing**  
  - `POST /api/images/edit`  
    • Body: `{ image_url: string, prompt: string }`  
    • Returns: new image URLs based on the edit prompt.

Each endpoint lives in a small serverless function that calls the appropriate service module, handles errors, and returns JSON.

---

## 5. Hosting Solutions

• **Supabase**  
  - Fully managed PostgreSQL and Auth.  
  - Global availability, automatic backups, and updates.

• **Serverless (Vercel or Netlify)**  
  - Host our API functions without provisioning servers.  
  - Auto-scale to handle spikes in AI calls.  
  - Easy rollbacks and preview deployments.

Why these choices?  
- **Reliability**: Both Supabase and leading serverless platforms aim for 99.9% uptime.  
- **Scalability**: Pay-as-you-go model—resources grow with traffic.  
- **Cost-Effectiveness**: No idle servers; you only pay for actual compute and database usage.

---

## 6. Infrastructure Components

• **Load Balancer and Edge Network**  
  - Provided by the serverless host for API functions and static assets.  

• **Content Delivery Network (CDN)**  
  - Static files (JavaScript, CSS, icons) are cached at CDN edge locations for fast global delivery.

• **Caching Mechanisms**  
  - HTTP caching headers for static assets.  
  - Optional in-memory cache (e.g., Redis) can be added later for prompt enhancement results.

• **Database Connection Pooling**  
  - Supabase’s managed service automatically pools connections for efficient usage.

All these pieces work together to keep response times low, reduce latency, and provide a seamless user experience worldwide.

---

## 7. Security Measures

• **Authentication & Authorization**  
  - Supabase uses JWTs for secure sessions.  
  - Row-Level Security ensures users only access their own projects.

• **Encryption**  
  - HTTPS/TLS for all traffic.  
  - Database encrypts data at rest by default.

• **API Key Management**  
  - Fal.ai and OpenAI keys live in serverless environment variables—never exposed to the browser.

• **Least Privilege**  
  - Service modules only have the permissions they need.  
  - Supabase database roles restrict writes and reads appropriately.

• **Data Validation**  
  - We validate user inputs at the API layer before writing to the database or calling AI services.

---

## 8. Monitoring and Maintenance

• **Logging & Error Tracking**  
  - Serverless logs accessible via Vercel/Netlify console.  
  - Integrate Sentry (or similar) for real-time error alerts.

• **Performance Monitoring**  
  - Supabase dashboard shows query performance and slow queries.  
  - Third-party services (e.g., Datadog) can track function execution times.

• **Uptime Checks**  
  - Use a service like UpTimeRobot to ping critical endpoints and alert us if something breaks.

• **Database Backups & Migrations**  
  - Supabase auto-backs up daily.  
  - Schema changes are applied via SQL migration files tracked in Git.

• **Routine Maintenance**  
  - Review logs weekly for unusual patterns.  
  - Update dependencies quarterly to patch security issues.

---

## 9. Conclusion and Overall Backend Summary

The backend relies on proven, managed services (Supabase, serverless platforms) and a clean, modular codebase. By separating AI integrations into individual service modules and enforcing security best practices, we achieve:

• **Reliability** through managed hosting and automated backups.  
• **Scalability** via serverless functions and pay-as-you-go database scaling.  
• **Maintainability** thanks to TypeScript, ESLint, and a clear folder structure.  
• **Performance** with CDNs, caching, and connection pooling.  
• **Security** by using JWTs, RLS, HTTPS, and environment-based key management.

This setup aligns perfectly with our goals: fast, secure, and cost-effective AI-powered design automation for any brand or designer.